**20210325**   
- 그리디 알고리즘   
큰 수의 법칙   
길이가 N인 배열에서 M번 반복해서 수를 더하는데 그 값이 최대가 되야한다. 그러나 하나의 수를 최대 반복해서 더할 수 있는건 K번으로 제한된다

당장 가장 큰수만 K번 더하고 그 다음 큰수를 1번 더한뒤 다시 반복한다.
*가장 큰 수*라는 조건이 있기때문에 당장 눈앞에 보이는 가장 큰수만 더해주면 최적해를 보장한다
K번 반복제한에 걸렸을 때는 *두 번째 큰 수*를 더해서 해결했다

**20210327**   
- 그리디 알고리즘
숫자 카드 게임
1. 행을 기준으로 수를 입력받아서 가장 작은 수들 중에
2. 가장 큰 수를 출력한다
가장작은, 가장 큰 이라는 용어가 명확하면 iterable한 data type으로 저장한뒤
순서대로 크고작음에 따라 분류해서 풀었다
그리디 알고리즘은 전반적으로 당장 눈앞의 이익(큰수, 작은수)가 최적해를 보장해야만 적용할 수 있는데
문제속에 제법 힌트가 들어있는거같다.
이외에 a = map(int, input().split()) 으로 코드를 작성하면 입력받은 수를 공백을 기준으로 각 데이터 타입을 int형으로 만든뒤 리스트에 저장해 준다

**20210328**
- 구현(완전탐색, 시뮬레이션)   
온라인 저지혹은 강의마다 부르는 표현이 다른데
개념적으로 좌표 평면을 만들고 이동하면서 좌표를 변경하는 문제 처럼 코드로 구현만하면 되는 문제들인데
특정한 알고리즘을 사용한다기 보다 단순히 for, if 로 표현이 가능한것이 대부분인데
로직은 굉장히 간단한데 그걸 코드로 구현해 내는 부분이 약간 어렵다. python built-in library를 숙지하는것이 문제 해결에 도움이 된다.

좌표평면이동 문제의 경우 2차원배열 개념으로 접근하기 보다는 x, y각 축의 boundary를 max로 설정하고
키보드 입력에 따라 캐릭터의 좌표위치를 각각의 변수 x, y에 저장하여 해결했다.

**20210329**
- 구현   
0시부터 입력받은시(5를 입력받으면 5시 59분 59초까지)까지 숫자 3이 나오는 모든 경우를 카운팅한다.
3시, 13시와 나머지 시간을 분리해서 계산했다.
연산량을 줄이기 위해 3이 없는 분의 초단위 계산은 별도로 분리해서 했다.
다만 문제에서 input이 5일경우 5시 59분 59초까지 계산해야되는데 잘못 읽고 4시 59분 59초까지만 계산하다가 계속 틀렸다.
구현문제의 경우 특별한 알고리즘이 없다보니 손부터 나가서 이런일이 발생하는듯 하다.

**20210330**   
- 구현   
개미수열   
개미수열을 recursion으로 해결한 적이 있는데 이번엔 재귀를 사용하지 않고 풀어야 한다는 조건이 추가됐다
모든 요소를 string타입으로 저장하고 각각의 인덱스 번호를 이용해 i번과 i+1번의 요소가 동일한지 아닌지를 판단해서 각각의 상황에 맞게 count를 늘려주거나
new_string에 문자열로 저장하는 방식을 사용했다. 가장 까다로웠던건 i + 1번의 인덱스가 out of range에 해당할 경우 였는데 이부분은 해당 string의 길이를 판단해서
i + 1이 string의 길이보다 밖의 범위에 있는지를 확인해서 간단하게 해결했다.

**20210405**   
- 구현    

마방진 33 마방진을 구현한다   
brute-force 인지 grid라고 해야할지 모르겠지만 for문을 3중첩을 여러번 사용해서 문제를 해결했다.
3차원 배열을 만들고 각 요소의 합이 15가 되는 배열을 모두 생성하고 다시 그 배열들을 선형으로 모두 순회하여 세로합, 대각선합이 15가 되는 걸 모두 찾았다.
그중에서 숫자가 1~9까지 중복되지 않은것들을 다시 판별한다. 이 모든과정을 모두 for3중첩으로 했는데 시간복잡도는 n^3만큼 발생하지만
처리해야할 데이터의 숫자 자체가 크지 않아서 연산에는 문제가 없다.
오히려 시간 복잡도에 집착해서 n^3으로 해결할 수 있는걸 괜히 어렵게 푸는걸 경계해야겠다. 구현, 시뮬레이션 문제는 다소 시간복잡도를 적게 고려해보자.

